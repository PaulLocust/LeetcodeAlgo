package ArrayString;

public class JumpGameTwo {
	/*
	 * Смысл алгоритма в том, что мы работаем с диапазоном индексов, доступных на конкретной позиции,
	 * то есть на примере {2,3,1,1,4} мы находимся в позиции 0 индекса, это 2, из двойки есть пути 2 -> |3,1|
	 * near указывает на самый первый индекс нашего прыжка, в начале алгоритма это ноль, потому что мы ещё никуда не прыгали,
	 * far обозначает самый дальний индекс на который мы можем прыгнуть с текущей позиции, в начале он тоже ноль, так
	 * как мы ещё не запустили итерации.
	 * И есть переменная jumps - она нужна для подсчёта кратчайшего пути до конца массива.
	 * 
	 *  Так как near = 0 и far = 0, вычислится Math.max... , near обновится и станет равно far + 1 = 1
	 *  (это индекс начала нашего диапазона прыжка с текущей позиции), а far станет равно пределу прыжка nums[i]+i = 2
	 *  
	 *  Переменная farthest нужна нам для определения самого выгодной позиции в диапазоне, которая обеспечит максимально
	 *  длинный прыжок.
	 *  
	 *  \Первая итерация/
	 *  ******************************** 
	 *  Итак, near = 1, far = 2, jumps = 1
	 *  ********************************
	 *   
	 *  На второй итерации как раз-таки и происходит анализ дальнейшей позиции, от которой можно будет максимально
	 *  далеко пропрыгать дальше. Для этого нужен цикл for в которой перебираются все значения из диапазона и переменная
	 *  farthest сохраняет только самое большое значение из всех предоставленных. А переменная near доходит до точки конца
	 *  первого диапазона и начальной точки от которой будет совершаться другой прыжок. near=[0] -> 1,3 -> near = [3] -> 4
	 *  
	 */
	public static void main(String[] args) {
		int[] nums = {2,1,3,1,4};
		int near = 0, far = 0, jumps = 0;
		while (far < nums.length-1) {
			int farthest = 0;
			for (int i = near; i <= far; i++) {
				farthest = Math.max(farthest, i+nums[i]);
			}
			near = far + 1;
			far = farthest;
			jumps++;
		}
		System.out.print(jumps);

	}
}
